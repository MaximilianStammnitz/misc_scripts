## default fitness estimation for nf-core/deepmutscan
## 27.10.2025
## maximilian.stammnitz@crg.eu

## 0. Libraries ##
##################

library(Biostrings)


## 1. Import key files ##
#########################

merged.counts <- read.table("fitness/counts_merged.tsv", sep = "\t", header = T)
exp.design <- read.table("fitness/experimentalDesign.tsv", sep = "\t", header = T)
wt.seq <- DNAString(as.character(read.table("fitness/synonymous_wt.txt")))
wt.seq.aa <- translate(wt.seq)


## 2. Pre-processing the count table ##
#######################################

## calculate nt hamming distances from the specified WT
merged.counts <- cbind("nt_ham" = rep(NA, nrow(merged.counts)), merged.counts)
for (i in 1:nrow(merged.counts)){
  tmp.wt <- strsplit(as.character(wt.seq), "")[[1]]
  tmp.mut <- strsplit(as.character(merged.counts$nt_seq[i]), "")[[1]]
  if(length(which(tmp.mut != tmp.wt)) == 0){
    merged.counts$nt_ham[i] <- 0
    rm(tmp.mut, tmp.wt)
    next
  }else{
    merged.counts$nt_ham[i] <- length(which(tmp.mut != tmp.wt))
    rm(tmp.mut, tmp.wt)
    next
  }
}

## translate sequences
merged.counts <- cbind("aa_seq" = as.character(translate(DNAStringSet(merged.counts$nt_seq))), merged.counts)

## calculate AA hamming distances from the WT
merged.counts <- cbind("aa_ham" = rep(NA, nrow(merged.counts)), merged.counts)
for (i in 1:nrow(merged.counts)){
  tmp.wt <- strsplit(as.character(wt.seq.aa), "")[[1]]
  tmp.mut <- strsplit(as.character(merged.counts$aa_seq[i]), "")[[1]]
  if(length(which(tmp.mut != tmp.wt)) == 0){
    merged.counts$aa_ham[i] <- 0
    rm(tmp.mut, tmp.wt)
    next
  }else{
    merged.counts$aa_ham[i] <- length(which(tmp.mut != tmp.wt))
    rm(tmp.mut, tmp.wt)
    next
  }
}

## name the mutations
merged.counts <- cbind("wt aa" = rep(NA, nrow(merged.counts)), 
                       "pos" = rep(NA, nrow(merged.counts)), 
                       "mut aa" = rep(NA, nrow(merged.counts)), merged.counts)
for (i in 1:nrow(merged.counts)){
  if(merged.counts$aa_ham[i] == 0){
    next
  }else{
    tmp.wt <- strsplit(as.character(wt.seq.aa), "")[[1]]
    tmp.mut <- strsplit(as.character(merged.counts$aa_seq[i]), "")[[1]]
    merged.counts$pos[i] <- which(tmp.mut != tmp.wt)
    merged.counts$`wt aa`[i] <- tmp.wt[merged.counts$pos[i]]
    merged.counts$`mut aa`[i] <- tmp.mut[merged.counts$pos[i]]
    rm(tmp.mut, tmp.wt)
  }
}

## find stops, WT and WT
merged.counts <- cbind(merged.counts,
                       "wt" = rep(NA, nrow(merged.counts)), 
                       "stop" = rep(NA, nrow(merged.counts)))
merged.counts$wt[which(merged.counts$nt_ham == 0)] <- T
merged.counts$stop[which(merged.counts$`mut aa` == "*")] <- T

## aggregate counts of variants which are identical on the aa (but not nt) level
## exception: wildtype ones
## thereby shrinking the matrix
uniq.aa.vars <- unique(merged.counts$aa_seq)
uniq.aa.vars <- uniq.aa.vars[-which(uniq.aa.vars == merged.counts$aa_seq[which(merged.counts$wt == T)])]
for(i in 1:length(uniq.aa.vars)){
  tmp.aa_seq <- uniq.aa.vars[i]
  hits <- which(as.character(merged.counts$aa_seq) == tmp.aa_seq)
  if(length(hits) == 1){
    rm(tmp.aa_seq, hits)
    next
  }else{
    for(j in grep("input|output", colnames(merged.counts))){
      merged.counts[hits[1],j] <- sum(merged.counts[hits,j], na.rm = T)
    }
    merged.counts[hits[1], "nt_seq"] <- paste(merged.counts[hits, "nt_seq"], collapse = ", ")
    merged.counts <- merged.counts[-hits[-1],]
    rm(tmp.aa_seq, hits)
    next
  }
}


## 3. Raw fitness calculations ##
#################################

## how many fitness replicates are there
reps <- length(unique(exp.design$experiment_replicate))
for (i in 1:reps){
  merged.counts <- cbind(merged.counts, rep(NA, nrow(merged.counts)))
  colnames(merged.counts)[ncol(merged.counts)] <- paste0("raw_fitness_rep", i)
}

## calculate raw fitness of all variants vs. WT variant
for (i in 1:reps){
  
  ### collect counts
  tmp.input.counts <- merged.counts[,paste0("input", i)]
  tmp.output.counts <- merged.counts[,paste0("output", i)]
  
  ### add pseudo-count to zero-outputs (if the corresponding input count is non-zero)
  tmp.output.counts[which(tmp.output.counts == 0 & tmp.input.counts != 0)] <- 1
  
  ### take logs
  tmp.wt.log.ratio <- log(tmp.output.counts[which(merged.counts$wt == T)] / 
                          tmp.input.counts[which(merged.counts$wt == T)])
  tmp.fitness <- log(tmp.output.counts / 
                     tmp.input.counts) - tmp.wt.log.ratio
  
  ### uncertain values to NA
  tmp.fitness[which(is.na(tmp.fitness) == T)] <- NA
  tmp.fitness[which(tmp.fitness == "Inf")] <- NA
  
  ### add to table
  merged.counts[,c(ncol(merged.counts) - reps + i)] <- tmp.fitness
  
  ### clean up
  rm(tmp.fitness, tmp.wt.log.ratio, tmp.output.counts, tmp.input.counts)
}


## 4. Fitness and error refinements ##
######################################

## center the raw fitness distributions on 0 (median of wildtype synonymous) and -1 (median of stops)
for (i in 1:reps){
  
  merged.counts <- cbind(merged.counts, rep(NA, nrow(merged.counts)))
  colnames(merged.counts)[ncol(merged.counts)] <- paste0("rescaled_fitness_rep", i)
  
  ### fetch the key counts
  tmp.wt.fitness <- merged.counts[which(merged.counts$aa_ham == 0),ncol(merged.counts) - reps]
  tmp.stop.fitness <- merged.counts[which(merged.counts$stop == T),ncol(merged.counts) - reps]
  
  ### rescale
  tmp.wt.fitness.med <- median(tmp.wt.fitness, na.rm = T)
  tmp.stop.fitness.med <- median(tmp.stop.fitness, na.rm = T)
  if(tmp.stop.fitness.med >= tmp.wt.fitness.med){
    
    tmp.wt.fitness.mean <- mean(tmp.wt.fitness, na.rm = T)
    tmp.stop.fitness.mean <- mean(tmp.stop.fitness, na.rm = T)
    lm.rescale <- lm(c(0, -1) ~ c(tmp.wt.fitness.mean, tmp.stop.fitness.mean))
    merged.counts[,ncol(merged.counts)] <- merged.counts[,ncol(merged.counts) - reps] * lm.rescale$coefficients[[2]] + lm.rescale$coefficients[[1]]
    rm(tmp.wt.fitness, tmp.stop.fitness, 
       tmp.wt.fitness.mean, tmp.stop.fitness.mean, 
       tmp.wt.fitness.med, tmp.stop.fitness.med, lm.rescale)
    next
    
  }else{
    
    lm.rescale <- lm(c(0, -1) ~ c(tmp.wt.fitness.med, tmp.stop.fitness.med))
    merged.counts[,ncol(merged.counts)] <- merged.counts[,ncol(merged.counts) - reps] * lm.rescale$coefficients[[2]] + lm.rescale$coefficients[[1]]
    rm(tmp.wt.fitness, tmp.stop.fitness, 
       tmp.wt.fitness.med, tmp.stop.fitness.med, lm.rescale)
    next
    
  }
}

## calculate fitness mean and standard deviation across replicates
merged.counts <- cbind(merged.counts,
                       "mean fitness" = rep(NA, nrow(merged.counts)),
                       "fitness sd" = rep(NA, nrow(merged.counts)))

if(reps == 1){
  
  merged.counts$`mean fitness` <- merged.counts[,ncol(merged.counts) - 2]

}else if(reps > 1){
 
  merged.counts$`mean fitness` <- apply(merged.counts[,c(ncol(merged.counts) - 2*reps + 1, ncol(merged.counts) - reps)],
                                        1,
                                        mean,
                                        na.rm = T)
  merged.counts$`fitness sd` <- apply(merged.counts[,c(ncol(merged.counts) - 2*reps + 1, ncol(merged.counts) - reps)],
                                      1,
                                      sd,
                                      na.rm = T)
  
}

## clean up
rm(reps, i, j)

## export
write.table(merged.counts, "fitness/fitness_estimation.tsv",
            col.names = T, row.names = F, quote = F, sep = "\t", na = "")


## 5. Version ##
################

# sessionInfo()
# R version 4.5.1 (2025-06-13)
# Platform: aarch64-apple-darwin20
# Running under: macOS Sonoma 14.6.1
# 
# Matrix products: default
# BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib 
# LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1
# 
# locale:
# [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
# 
# time zone: Europe/Madrid
# tzcode source: internal
# 
# attached base packages:
# [1] stats4    stats     graphics  grDevices utils     datasets  methods   base     
# 
# other attached packages:
# [1] Biostrings_2.76.0   GenomeInfoDb_1.44.2 XVector_0.48.0      IRanges_2.42.0      S4Vectors_0.46.0   
# [6] BiocGenerics_0.54.0 generics_0.1.4     
# 
# loaded via a namespace (and not attached):
# [1] httr_1.4.7              compiler_4.5.1          R6_2.6.1                tools_4.5.1            
# [5] GenomeInfoDbData_1.2.14 rstudioapi_0.17.1       crayon_1.5.3            UCSC.utils_1.4.0       
# [9] jsonlite_2.0.0   
