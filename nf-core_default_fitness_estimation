## default fitness estimation for nf-core/deepmutscan
## includes two visualisations
## 31.10.2025
## maximilian.stammnitz@crg.eu

## 0. Libraries ##
##################

library(Biostrings)


## 1. Import key files ##
#########################

merged.counts <- read.table("fitness/counts_merged.tsv", sep = "\t", header = T)
exp.design <- read.table("fitness/experimentalDesign.tsv", sep = "\t", header = T)
wt.seq <- DNAString(as.character(read.table("fitness/synonymous_wt.txt")))
wt.seq.aa <- translate(wt.seq)


## 2. Pre-processing the count table ##
#######################################

## calculate nt hamming distances from the specified WT
merged.counts <- cbind("nt_ham" = rep(NA, nrow(merged.counts)), merged.counts)
for (i in 1:nrow(merged.counts)){
  tmp.wt <- strsplit(as.character(wt.seq), "")[[1]]
  tmp.mut <- strsplit(as.character(merged.counts$nt_seq[i]), "")[[1]]
  if(length(which(tmp.mut != tmp.wt)) == 0){
    merged.counts$nt_ham[i] <- 0
    rm(tmp.mut, tmp.wt)
    next
  }else{
    merged.counts$nt_ham[i] <- length(which(tmp.mut != tmp.wt))
    rm(tmp.mut, tmp.wt)
    next
  }
}

## translate sequences
merged.counts <- cbind("aa_seq" = as.character(translate(DNAStringSet(merged.counts$nt_seq))), merged.counts)

## calculate AA hamming distances from the WT
merged.counts <- cbind("aa_ham" = rep(NA, nrow(merged.counts)), merged.counts)
for (i in 1:nrow(merged.counts)){
  tmp.wt <- strsplit(as.character(wt.seq.aa), "")[[1]]
  tmp.mut <- strsplit(as.character(merged.counts$aa_seq[i]), "")[[1]]
  if(length(which(tmp.mut != tmp.wt)) == 0){
    merged.counts$aa_ham[i] <- 0
    rm(tmp.mut, tmp.wt)
    next
  }else{
    merged.counts$aa_ham[i] <- length(which(tmp.mut != tmp.wt))
    rm(tmp.mut, tmp.wt)
    next
  }
}

## name the mutations
merged.counts <- cbind("wt aa" = rep(NA, nrow(merged.counts)), 
                       "pos" = rep(NA, nrow(merged.counts)), 
                       "mut aa" = rep(NA, nrow(merged.counts)), merged.counts)
for (i in 1:nrow(merged.counts)){
  if(merged.counts$aa_ham[i] == 0){
    next
  }else{
    tmp.wt <- strsplit(as.character(wt.seq.aa), "")[[1]]
    tmp.mut <- strsplit(as.character(merged.counts$aa_seq[i]), "")[[1]]
    merged.counts$pos[i] <- which(tmp.mut != tmp.wt)
    merged.counts$`wt aa`[i] <- tmp.wt[merged.counts$pos[i]]
    merged.counts$`mut aa`[i] <- tmp.mut[merged.counts$pos[i]]
    rm(tmp.mut, tmp.wt)
  }
}

## find stops, WT and WT
merged.counts <- cbind(merged.counts,
                       "wt" = rep(NA, nrow(merged.counts)), 
                       "stop" = rep(NA, nrow(merged.counts)))
merged.counts$wt[which(merged.counts$nt_ham == 0)] <- T
merged.counts$stop[which(merged.counts$`mut aa` == "*")] <- T

## aggregate counts of variants which are identical on the aa (but not nt) level
## exception: wildtype ones
## thereby shrinking the matrix
uniq.aa.vars <- unique(merged.counts$aa_seq)
uniq.aa.vars <- uniq.aa.vars[-which(uniq.aa.vars == merged.counts$aa_seq[which(merged.counts$wt == T)])]
for(i in 1:length(uniq.aa.vars)){
  tmp.aa_seq <- uniq.aa.vars[i]
  hits <- which(as.character(merged.counts$aa_seq) == tmp.aa_seq)
  if(length(hits) == 1){
    rm(tmp.aa_seq, hits)
    next
  }else{
    for(j in grep("input|output", colnames(merged.counts))){
      merged.counts[hits[1],j] <- sum(merged.counts[hits,j], na.rm = T)
    }
    merged.counts[hits[1], "nt_seq"] <- paste(merged.counts[hits, "nt_seq"], collapse = ", ")
    merged.counts <- merged.counts[-hits[-1],]
    rm(tmp.aa_seq, hits)
    next
  }
}


## 3. Raw fitness calculations ##
#################################

## how many fitness replicates are there
reps <- length(unique(exp.design$experiment_replicate))
for (i in 1:reps){
  merged.counts <- cbind(merged.counts, rep(NA, nrow(merged.counts)))
  colnames(merged.counts)[ncol(merged.counts)] <- paste0("raw_fitness_rep", i)
}

## calculate raw fitness of all variants vs. WT variant
for (i in 1:reps){
  
  ### collect counts
  tmp.input.counts <- merged.counts[,paste0("input", i)]
  tmp.output.counts <- merged.counts[,paste0("output", i)]
  
  ### add pseudo-count to zero-outputs (if the corresponding input count is non-zero)
  tmp.output.counts[which(tmp.output.counts == 0 & tmp.input.counts != 0)] <- 1
  
  ### take logs
  tmp.wt.log.ratio <- log(tmp.output.counts[which(merged.counts$wt == T)] / 
                          tmp.input.counts[which(merged.counts$wt == T)])
  tmp.fitness <- log(tmp.output.counts / 
                     tmp.input.counts) - tmp.wt.log.ratio
  
  ### uncertain values to NA
  tmp.fitness[which(is.na(tmp.fitness) == T)] <- NA
  tmp.fitness[which(tmp.fitness == "Inf")] <- NA
  
  ### add to table
  merged.counts[,c(ncol(merged.counts) - reps + i)] <- tmp.fitness
  
  ### clean up
  rm(tmp.fitness, tmp.wt.log.ratio, tmp.output.counts, tmp.input.counts)
}


## 4. Fitness and error refinements ##
######################################

## center the raw fitness distributions on 0 (median of wildtype synonymous) and -1 (median of stops)
for (i in 1:reps){
  
  merged.counts <- cbind(merged.counts, rep(NA, nrow(merged.counts)))
  colnames(merged.counts)[ncol(merged.counts)] <- paste0("rescaled_fitness_rep", i)
  
  ### fetch the key counts
  tmp.wt.fitness <- merged.counts[which(merged.counts$aa_ham == 0),ncol(merged.counts) - reps]
  tmp.stop.fitness <- merged.counts[which(merged.counts$stop == T),ncol(merged.counts) - reps]
  
  ### rescale
  tmp.wt.fitness.med <- median(tmp.wt.fitness, na.rm = T)
  tmp.stop.fitness.med <- median(tmp.stop.fitness, na.rm = T)
  if(tmp.stop.fitness.med >= tmp.wt.fitness.med){
    
    tmp.wt.fitness.mean <- mean(tmp.wt.fitness, na.rm = T)
    tmp.stop.fitness.mean <- mean(tmp.stop.fitness, na.rm = T)
    lm.rescale <- lm(c(0, -1) ~ c(tmp.wt.fitness.mean, tmp.stop.fitness.mean))
    merged.counts[,ncol(merged.counts)] <- merged.counts[,ncol(merged.counts) - reps] * lm.rescale$coefficients[[2]] + lm.rescale$coefficients[[1]]
    rm(tmp.wt.fitness, tmp.stop.fitness, 
       tmp.wt.fitness.mean, tmp.stop.fitness.mean, 
       tmp.wt.fitness.med, tmp.stop.fitness.med, lm.rescale)
    next
    
  }else{
    
    lm.rescale <- lm(c(0, -1) ~ c(tmp.wt.fitness.med, tmp.stop.fitness.med))
    merged.counts[,ncol(merged.counts)] <- merged.counts[,ncol(merged.counts) - reps] * lm.rescale$coefficients[[2]] + lm.rescale$coefficients[[1]]
    rm(tmp.wt.fitness, tmp.stop.fitness, 
       tmp.wt.fitness.med, tmp.stop.fitness.med, lm.rescale)
    next
    
  }
}

## calculate fitness mean and standard deviation across replicates
merged.counts <- cbind(merged.counts,
                       "mean fitness" = rep(NA, nrow(merged.counts)),
                       "fitness sd" = rep(NA, nrow(merged.counts)))

if(reps == 1){
  
  merged.counts$`mean fitness` <- merged.counts[,ncol(merged.counts) - 2]

}else if(reps > 1){
 
  merged.counts$`mean fitness` <- apply(merged.counts[,c(ncol(merged.counts) - 2*reps + 1, ncol(merged.counts) - reps)],
                                        1,
                                        mean,
                                        na.rm = T)
  merged.counts$`fitness sd` <- apply(merged.counts[,c(ncol(merged.counts) - 2*reps + 1, ncol(merged.counts) - reps)],
                                      1,
                                      sd,
                                      na.rm = T)
  
}

## clean up
rm(reps, i, j)

## export
write.table(merged.counts, "fitness/fitness_estimation.tsv",
            col.names = T, row.names = F, quote = F, sep = "\t", na = "")


## 5. Plot input vs. output counts ##
#####################################

merged.counts.fitness <- read.table("fitness/fitness_estimation.tsv", sep = "\t", header = T)

## identify the right samples
inputs <- grep("input", colnames(merged.counts.fitness))
outputs <- grep("output", colnames(merged.counts.fitness))

# lower panels: scatter + x=y
panel_xy_abline <- function(x, y, ...) {
  op <- par("xpd"); on.exit(par(xpd = op), add = TRUE)
  par(xpd = FALSE)
  points(x, y, pch = 16, cex = 0.1, ...)
  abline(a = 0, b = 1, lty = 2, col = "grey50")
}

# upper panels: Pearson r (log-log-transformed)
panel_cor <- function(x, y, digits = 2, prefix = "r = ", cex.text = 1.4, ...) {
  
  r <- suppressWarnings(cor(log(x), log(y), use = "pairwise.complete.obs", method = "pearson"))
  lab <- if (is.finite(r)) bquote(italic(r) == .(round(r, digits))) else bquote(italic(r) == NA)
  
  # Save/restore full graphics state we touch
  op <- par(c("usr", "xpd", "xlog", "ylog"))
  on.exit(par(op), add = TRUE)
  
  # Draw in normalized 0..1 panel coords with logs OFF so text is visible
  par(xlog = FALSE, ylog = FALSE, xpd = FALSE, usr = c(0, 1, 0, 1))
  text(0.5, 0.5, labels = lab, cex = cex.text, font = 1, col = "black")
}

pdf("fitness/fitness_estimation_count_correlation.pdf", height = 9, width = 14)
pairs(merged.counts.fitness[, c(inputs, outputs)] + 1, ## use a pseudo-count
      lower.panel = panel_xy_abline,
      upper.panel = panel_cor,
      cex.text = 2,
      log = "xy")
dev.off()


## 6. Plot fitness correlations ##
##################################

## identify the right samples
fitness.repl <- grep("rescaled_fitness", colnames(merged.counts.fitness))

if(length(fitness.repl) > 1){
  
  # lower panels: scatter + x=y
  panel_xy_abline <- function(x, y, ...) {
    op <- par("xpd"); on.exit(par(xpd = op), add = TRUE)
    par(xpd = FALSE)
    points(x, y, pch = 16, cex = 0.5, ...)
    abline(a = 0, b = 1, lty = 2, col = "grey50")
  }
  
  # upper panels: Pearson r
  panel_cor <- function(x, y, digits = 2, prefix = "r = ", cex.text = 1.4, ...) {
    
    r <- suppressWarnings(cor(x, y, use = "pairwise.complete.obs", method = "pearson"))
    lab <- if (is.finite(r)) bquote(italic(r) == .(round(r, digits))) else bquote(italic(r) == NA)
    
    # Save/restore full graphics state we touch
    op <- par(c("usr", "xpd", "xlog", "ylog"))
    on.exit(par(op), add = TRUE)
    
    # Draw in normalized 0..1 panel coords with logs OFF so text is visible
    par(xlog = FALSE, ylog = FALSE, xpd = FALSE, usr = c(0, 1, 0, 1))
    text(0.5, 0.5, labels = lab, cex = cex.text, font = 1, col = "black")
  }
  
  pdf("fitness_estimation_fitness_correlation.pdf", height = 9, width = 14)
  pairs(merged.counts.fitness[, fitness.repl],
        lower.panel = panel_xy_abline,
        upper.panel = panel_cor,
        cex.text = 2,
        xlim = c(-3,1),
        ylim = c(-3,1))
  dev.off()  
  
}


## 7. Version ##
################

# sessionInfo()
# R version 4.5.1 (2025-06-13)
# Platform: aarch64-apple-darwin20
# Running under: macOS Sonoma 14.6.1
# 
# Matrix products: default
# BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib 
# LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1
# 
# locale:
# [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
# 
# time zone: Europe/Madrid
# tzcode source: internal
# 
# attached base packages:
# [1] stats4    stats     graphics  grDevices utils     datasets  methods   base     
# 
# other attached packages:
# [1] Biostrings_2.76.0   GenomeInfoDb_1.44.2 XVector_0.48.0      IRanges_2.42.0      S4Vectors_0.46.0   
# [6] BiocGenerics_0.54.0 generics_0.1.4     
# 
# loaded via a namespace (and not attached):
# [1] httr_1.4.7              compiler_4.5.1          R6_2.6.1                tools_4.5.1            
# [5] GenomeInfoDbData_1.2.14 rstudioapi_0.17.1       crayon_1.5.3            UCSC.utils_1.4.0       
# [9] jsonlite_2.0.0   
